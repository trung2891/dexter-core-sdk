/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.28.0.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
import {AutoStakeImpl, Addr, AllowPoolInstantiation, PoolType, PoolCreationFee, Uint128, AssetInfo, PoolTypeConfig, FeeInfo, PauseInfo, Asset, Binary, PauseInfoUpdateType, Decimal, SwapType, Cw20ReceiveMsg, NativeAssetPrecisionInfo, SingleSwapRequest, DescriptionThisStructDescribesTheMainControlConfigOfVault, PoolInfo, NullablePoolTypeConfig} from "./types";
import {InstantiateMsg, ExecuteMsg, QueryMsg, MigrateMsg} from "./Vault.types";
export interface VaultReadOnlyInterface {
  contractAddress: string;
  config: () => Promise<DescriptionThisStructDescribesTheMainControlConfigOfVault>;
  queryRegistry: ({
    poolType
  }: {
    poolType: PoolType;
  }) => Promise<NullablePoolTypeConfig>;
  getPoolById: ({
    poolId
  }: {
    poolId: Uint128;
  }) => Promise<PoolInfo>;
  getPoolByAddress: ({
    poolAddr
  }: {
    poolAddr: string;
  }) => Promise<PoolInfo>;
  getPoolByLpTokenAddress: ({
    lpTokenAddr
  }: {
    lpTokenAddr: string;
  }) => Promise<PoolInfo>;
}
export class VaultQueryClient implements VaultReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.config = this.config.bind(this);
    this.queryRegistry = this.queryRegistry.bind(this);
    this.getPoolById = this.getPoolById.bind(this);
    this.getPoolByAddress = this.getPoolByAddress.bind(this);
    this.getPoolByLpTokenAddress = this.getPoolByLpTokenAddress.bind(this);
  }

  config = async (): Promise<DescriptionThisStructDescribesTheMainControlConfigOfVault> => {
    return this.client.queryContractSmart(this.contractAddress, {
      config: {}
    });
  };
  queryRegistry = async ({
    poolType
  }: {
    poolType: PoolType;
  }): Promise<NullablePoolTypeConfig> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_registry: {
        pool_type: poolType
      }
    });
  };
  getPoolById = async ({
    poolId
  }: {
    poolId: Uint128;
  }): Promise<PoolInfo> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_pool_by_id: {
        pool_id: poolId
      }
    });
  };
  getPoolByAddress = async ({
    poolAddr
  }: {
    poolAddr: string;
  }): Promise<PoolInfo> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_pool_by_address: {
        pool_addr: poolAddr
      }
    });
  };
  getPoolByLpTokenAddress = async ({
    lpTokenAddr
  }: {
    lpTokenAddr: string;
  }): Promise<PoolInfo> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_pool_by_lp_token_address: {
        lp_token_addr: lpTokenAddr
      }
    });
  };
}
export interface VaultInterface extends VaultReadOnlyInterface {
  contractAddress: string;
  sender: string;
  receive: ({
    amount,
    msg,
    sender
  }: {
    amount: Uint128;
    msg: Binary;
    sender: string;
  }, $fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
  updateConfig: ({
    autoStakeImpl,
    feeCollector,
    lpTokenCodeId,
    paused,
    poolCreationFee
  }: {
    autoStakeImpl?: AutoStakeImpl;
    feeCollector?: string;
    lpTokenCodeId?: number;
    paused?: PauseInfo;
    poolCreationFee?: PoolCreationFee;
  }, $fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
  addAddressToWhitelist: ({
    address
  }: {
    address: string;
  }, $fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
  removeAddressFromWhitelist: ({
    address
  }: {
    address: string;
  }, $fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
  updatePauseInfo: ({
    pauseInfo,
    updateType
  }: {
    pauseInfo: PauseInfo;
    updateType: PauseInfoUpdateType;
  }, $fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
  updatePoolTypeConfig: ({
    allowInstantiation,
    newFeeInfo,
    paused,
    poolType
  }: {
    allowInstantiation?: AllowPoolInstantiation;
    newFeeInfo?: FeeInfo;
    paused?: PauseInfo;
    poolType: PoolType;
  }, $fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
  addToRegistry: ({
    newPoolTypeConfig
  }: {
    newPoolTypeConfig: PoolTypeConfig;
  }, $fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
  createPoolInstance: ({
    assetInfos,
    feeInfo,
    initParams,
    nativeAssetPrecisions,
    poolType
  }: {
    assetInfos: AssetInfo[];
    feeInfo?: FeeInfo;
    initParams?: Binary;
    nativeAssetPrecisions: NativeAssetPrecisionInfo[];
    poolType: PoolType;
  }, $fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
  updatePoolConfig: ({
    feeInfo,
    paused,
    poolId
  }: {
    feeInfo?: FeeInfo;
    paused?: PauseInfo;
    poolId: Uint128;
  }, $fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
  updatePoolParams: ({
    params,
    poolId
  }: {
    params: Binary;
    poolId: Uint128;
  }, $fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
  joinPool: ({
    assets,
    autoStake,
    minLpToReceive,
    poolId,
    recipient
  }: {
    assets?: Asset[];
    autoStake?: boolean;
    minLpToReceive?: Uint128;
    poolId: Uint128;
    recipient?: string;
  }, $fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
  swap: ({
    maxSpend,
    minReceive,
    recipient,
    swapRequest
  }: {
    maxSpend?: Uint128;
    minReceive?: Uint128;
    recipient?: string;
    swapRequest: SingleSwapRequest;
  }, $fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
  proposeNewOwner: ({
    expiresIn,
    newOwner
  }: {
    expiresIn: number;
    newOwner: string;
  }, $fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
  dropOwnershipProposal: ($fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
  claimOwnership: ($fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
}
export class VaultClient extends VaultQueryClient implements VaultInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.receive = this.receive.bind(this);
    this.updateConfig = this.updateConfig.bind(this);
    this.addAddressToWhitelist = this.addAddressToWhitelist.bind(this);
    this.removeAddressFromWhitelist = this.removeAddressFromWhitelist.bind(this);
    this.updatePauseInfo = this.updatePauseInfo.bind(this);
    this.updatePoolTypeConfig = this.updatePoolTypeConfig.bind(this);
    this.addToRegistry = this.addToRegistry.bind(this);
    this.createPoolInstance = this.createPoolInstance.bind(this);
    this.updatePoolConfig = this.updatePoolConfig.bind(this);
    this.updatePoolParams = this.updatePoolParams.bind(this);
    this.joinPool = this.joinPool.bind(this);
    this.swap = this.swap.bind(this);
    this.proposeNewOwner = this.proposeNewOwner.bind(this);
    this.dropOwnershipProposal = this.dropOwnershipProposal.bind(this);
    this.claimOwnership = this.claimOwnership.bind(this);
  }

  receive = async ({
    amount,
    msg,
    sender
  }: {
    amount: Uint128;
    msg: Binary;
    sender: string;
  }, $fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      receive: {
        amount,
        msg,
        sender
      }
    }, $fee, $memo, $funds);
  };
  updateConfig = async ({
    autoStakeImpl,
    feeCollector,
    lpTokenCodeId,
    paused,
    poolCreationFee
  }: {
    autoStakeImpl?: AutoStakeImpl;
    feeCollector?: string;
    lpTokenCodeId?: number;
    paused?: PauseInfo;
    poolCreationFee?: PoolCreationFee;
  }, $fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_config: {
        auto_stake_impl: autoStakeImpl,
        fee_collector: feeCollector,
        lp_token_code_id: lpTokenCodeId,
        paused,
        pool_creation_fee: poolCreationFee
      }
    }, $fee, $memo, $funds);
  };
  addAddressToWhitelist = async ({
    address
  }: {
    address: string;
  }, $fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      add_address_to_whitelist: {
        address
      }
    }, $fee, $memo, $funds);
  };
  removeAddressFromWhitelist = async ({
    address
  }: {
    address: string;
  }, $fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      remove_address_from_whitelist: {
        address
      }
    }, $fee, $memo, $funds);
  };
  updatePauseInfo = async ({
    pauseInfo,
    updateType
  }: {
    pauseInfo: PauseInfo;
    updateType: PauseInfoUpdateType;
  }, $fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_pause_info: {
        pause_info: pauseInfo,
        update_type: updateType
      }
    }, $fee, $memo, $funds);
  };
  updatePoolTypeConfig = async ({
    allowInstantiation,
    newFeeInfo,
    paused,
    poolType
  }: {
    allowInstantiation?: AllowPoolInstantiation;
    newFeeInfo?: FeeInfo;
    paused?: PauseInfo;
    poolType: PoolType;
  }, $fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_pool_type_config: {
        allow_instantiation: allowInstantiation,
        new_fee_info: newFeeInfo,
        paused,
        pool_type: poolType
      }
    }, $fee, $memo, $funds);
  };
  addToRegistry = async ({
    newPoolTypeConfig
  }: {
    newPoolTypeConfig: PoolTypeConfig;
  }, $fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      add_to_registry: {
        new_pool_type_config: newPoolTypeConfig
      }
    }, $fee, $memo, $funds);
  };
  createPoolInstance = async ({
    assetInfos,
    feeInfo,
    initParams,
    nativeAssetPrecisions,
    poolType
  }: {
    assetInfos: AssetInfo[];
    feeInfo?: FeeInfo;
    initParams?: Binary;
    nativeAssetPrecisions: NativeAssetPrecisionInfo[];
    poolType: PoolType;
  }, $fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      create_pool_instance: {
        asset_infos: assetInfos,
        fee_info: feeInfo,
        init_params: initParams,
        native_asset_precisions: nativeAssetPrecisions,
        pool_type: poolType
      }
    }, $fee, $memo, $funds);
  };
  updatePoolConfig = async ({
    feeInfo,
    paused,
    poolId
  }: {
    feeInfo?: FeeInfo;
    paused?: PauseInfo;
    poolId: Uint128;
  }, $fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_pool_config: {
        fee_info: feeInfo,
        paused,
        pool_id: poolId
      }
    }, $fee, $memo, $funds);
  };
  updatePoolParams = async ({
    params,
    poolId
  }: {
    params: Binary;
    poolId: Uint128;
  }, $fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_pool_params: {
        params,
        pool_id: poolId
      }
    }, $fee, $memo, $funds);
  };
  joinPool = async ({
    assets,
    autoStake,
    minLpToReceive,
    poolId,
    recipient
  }: {
    assets?: Asset[];
    autoStake?: boolean;
    minLpToReceive?: Uint128;
    poolId: Uint128;
    recipient?: string;
  }, $fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      join_pool: {
        assets,
        auto_stake: autoStake,
        min_lp_to_receive: minLpToReceive,
        pool_id: poolId,
        recipient
      }
    }, $fee, $memo, $funds);
  };
  swap = async ({
    maxSpend,
    minReceive,
    recipient,
    swapRequest
  }: {
    maxSpend?: Uint128;
    minReceive?: Uint128;
    recipient?: string;
    swapRequest: SingleSwapRequest;
  }, $fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      swap: {
        max_spend: maxSpend,
        min_receive: minReceive,
        recipient,
        swap_request: swapRequest
      }
    }, $fee, $memo, $funds);
  };
  proposeNewOwner = async ({
    expiresIn,
    newOwner
  }: {
    expiresIn: number;
    newOwner: string;
  }, $fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      propose_new_owner: {
        expires_in: expiresIn,
        new_owner: newOwner
      }
    }, $fee, $memo, $funds);
  };
  dropOwnershipProposal = async ($fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      drop_ownership_proposal: {}
    }, $fee, $memo, $funds);
  };
  claimOwnership = async ($fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      claim_ownership: {}
    }, $fee, $memo, $funds);
  };
}