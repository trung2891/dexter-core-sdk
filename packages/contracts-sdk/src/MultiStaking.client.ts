/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.28.0.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
import {Addr, Uint128, Binary, ReviewProposedRewardSchedule, Cw20ReceiveMsg, TokenLock, AssetInfo, ArrayOfAddr, Config, CreatorClaimableRewardState, InstantLpUnlockFee, ArrayOfUnlockFeeTier, UnlockFeeTier, ProposedRewardSchedule, Asset, ArrayOfTokenLock, RewardSchedule, Decimal, AssetRewardState, AssetStakerInfo, TokenLockInfo, ArrayOfUnclaimedReward, UnclaimedReward} from "./types";
import {InstantiateMsg, ExecuteMsg, QueryMsg, MigrateMsg, ArrayOfProposedRewardSchedulesResponse, ProposedRewardSchedulesResponse, ArrayOfRewardScheduleResponse, RewardScheduleResponse} from "./MultiStaking.types";
export interface MultiStakingReadOnlyInterface {
  contractAddress: string;
  config: () => Promise<Config>;
  unclaimedRewards: ({
    blockTime,
    lpToken,
    user
  }: {
    blockTime?: number;
    lpToken: Addr;
    user: Addr;
  }) => Promise<ArrayOfUnclaimedReward>;
  tokenLocks: ({
    blockTime,
    lpToken,
    user
  }: {
    blockTime?: number;
    lpToken: Addr;
    user: Addr;
  }) => Promise<TokenLockInfo>;
  rawTokenLocks: ({
    lpToken,
    user
  }: {
    lpToken: Addr;
    user: Addr;
  }) => Promise<ArrayOfTokenLock>;
  bondedLpTokens: ({
    lpToken,
    user
  }: {
    lpToken: Addr;
    user: Addr;
  }) => Promise<Uint128>;
  instantUnlockFee: ({
    lpToken,
    tokenLock,
    user
  }: {
    lpToken: Addr;
    tokenLock: TokenLock;
    user: Addr;
  }) => Promise<InstantLpUnlockFee>;
  instantUnlockFeeTiers: () => Promise<ArrayOfUnlockFeeTier>;
  allowedLPTokensForReward: () => Promise<ArrayOfAddr>;
  owner: () => Promise<Addr>;
  proposedRewardSchedules: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number;
  }) => Promise<ArrayOfProposedRewardSchedulesResponse>;
  proposedRewardSchedule: ({
    proposalId
  }: {
    proposalId: number;
  }) => Promise<ProposedRewardSchedule>;
  rewardSchedules: ({
    asset,
    lpToken
  }: {
    asset: AssetInfo;
    lpToken: Addr;
  }) => Promise<ArrayOfRewardScheduleResponse>;
  rewardState: ({
    asset,
    lpToken
  }: {
    asset: AssetInfo;
    lpToken: Addr;
  }) => Promise<AssetRewardState>;
  stakerInfo: ({
    asset,
    lpToken,
    user
  }: {
    asset: AssetInfo;
    lpToken: Addr;
    user: Addr;
  }) => Promise<AssetStakerInfo>;
  creatorClaimableReward: ({
    rewardScheduleId
  }: {
    rewardScheduleId: number;
  }) => Promise<CreatorClaimableRewardState>;
}
export class MultiStakingQueryClient implements MultiStakingReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.config = this.config.bind(this);
    this.unclaimedRewards = this.unclaimedRewards.bind(this);
    this.tokenLocks = this.tokenLocks.bind(this);
    this.rawTokenLocks = this.rawTokenLocks.bind(this);
    this.bondedLpTokens = this.bondedLpTokens.bind(this);
    this.instantUnlockFee = this.instantUnlockFee.bind(this);
    this.instantUnlockFeeTiers = this.instantUnlockFeeTiers.bind(this);
    this.allowedLPTokensForReward = this.allowedLPTokensForReward.bind(this);
    this.owner = this.owner.bind(this);
    this.proposedRewardSchedules = this.proposedRewardSchedules.bind(this);
    this.proposedRewardSchedule = this.proposedRewardSchedule.bind(this);
    this.rewardSchedules = this.rewardSchedules.bind(this);
    this.rewardState = this.rewardState.bind(this);
    this.stakerInfo = this.stakerInfo.bind(this);
    this.creatorClaimableReward = this.creatorClaimableReward.bind(this);
  }

  config = async (): Promise<Config> => {
    return this.client.queryContractSmart(this.contractAddress, {
      config: {}
    });
  };
  unclaimedRewards = async ({
    blockTime,
    lpToken,
    user
  }: {
    blockTime?: number;
    lpToken: Addr;
    user: Addr;
  }): Promise<ArrayOfUnclaimedReward> => {
    return this.client.queryContractSmart(this.contractAddress, {
      unclaimed_rewards: {
        block_time: blockTime,
        lp_token: lpToken,
        user
      }
    });
  };
  tokenLocks = async ({
    blockTime,
    lpToken,
    user
  }: {
    blockTime?: number;
    lpToken: Addr;
    user: Addr;
  }): Promise<TokenLockInfo> => {
    return this.client.queryContractSmart(this.contractAddress, {
      token_locks: {
        block_time: blockTime,
        lp_token: lpToken,
        user
      }
    });
  };
  rawTokenLocks = async ({
    lpToken,
    user
  }: {
    lpToken: Addr;
    user: Addr;
  }): Promise<ArrayOfTokenLock> => {
    return this.client.queryContractSmart(this.contractAddress, {
      raw_token_locks: {
        lp_token: lpToken,
        user
      }
    });
  };
  bondedLpTokens = async ({
    lpToken,
    user
  }: {
    lpToken: Addr;
    user: Addr;
  }): Promise<Uint128> => {
    return this.client.queryContractSmart(this.contractAddress, {
      bonded_lp_tokens: {
        lp_token: lpToken,
        user
      }
    });
  };
  instantUnlockFee = async ({
    lpToken,
    tokenLock,
    user
  }: {
    lpToken: Addr;
    tokenLock: TokenLock;
    user: Addr;
  }): Promise<InstantLpUnlockFee> => {
    return this.client.queryContractSmart(this.contractAddress, {
      instant_unlock_fee: {
        lp_token: lpToken,
        token_lock: tokenLock,
        user
      }
    });
  };
  instantUnlockFeeTiers = async (): Promise<ArrayOfUnlockFeeTier> => {
    return this.client.queryContractSmart(this.contractAddress, {
      instant_unlock_fee_tiers: {}
    });
  };
  allowedLPTokensForReward = async (): Promise<ArrayOfAddr> => {
    return this.client.queryContractSmart(this.contractAddress, {
      allowed_l_p_tokens_for_reward: {}
    });
  };
  owner = async (): Promise<Addr> => {
    return this.client.queryContractSmart(this.contractAddress, {
      owner: {}
    });
  };
  proposedRewardSchedules = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number;
  }): Promise<ArrayOfProposedRewardSchedulesResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      proposed_reward_schedules: {
        limit,
        start_after: startAfter
      }
    });
  };
  proposedRewardSchedule = async ({
    proposalId
  }: {
    proposalId: number;
  }): Promise<ProposedRewardSchedule> => {
    return this.client.queryContractSmart(this.contractAddress, {
      proposed_reward_schedule: {
        proposal_id: proposalId
      }
    });
  };
  rewardSchedules = async ({
    asset,
    lpToken
  }: {
    asset: AssetInfo;
    lpToken: Addr;
  }): Promise<ArrayOfRewardScheduleResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      reward_schedules: {
        asset,
        lp_token: lpToken
      }
    });
  };
  rewardState = async ({
    asset,
    lpToken
  }: {
    asset: AssetInfo;
    lpToken: Addr;
  }): Promise<AssetRewardState> => {
    return this.client.queryContractSmart(this.contractAddress, {
      reward_state: {
        asset,
        lp_token: lpToken
      }
    });
  };
  stakerInfo = async ({
    asset,
    lpToken,
    user
  }: {
    asset: AssetInfo;
    lpToken: Addr;
    user: Addr;
  }): Promise<AssetStakerInfo> => {
    return this.client.queryContractSmart(this.contractAddress, {
      staker_info: {
        asset,
        lp_token: lpToken,
        user
      }
    });
  };
  creatorClaimableReward = async ({
    rewardScheduleId
  }: {
    rewardScheduleId: number;
  }): Promise<CreatorClaimableRewardState> => {
    return this.client.queryContractSmart(this.contractAddress, {
      creator_claimable_reward: {
        reward_schedule_id: rewardScheduleId
      }
    });
  };
}
export interface MultiStakingInterface extends MultiStakingReadOnlyInterface {
  contractAddress: string;
  sender: string;
  updateConfig: ({
    feeTierInterval,
    instantUnbondFeeBp,
    instantUnbondMinFeeBp,
    keeperAddr,
    minimumRewardScheduleProposalStartDelay,
    unlockPeriod
  }: {
    feeTierInterval?: number;
    instantUnbondFeeBp?: number;
    instantUnbondMinFeeBp?: number;
    keeperAddr?: Addr;
    minimumRewardScheduleProposalStartDelay?: number;
    unlockPeriod?: number;
  }, $fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
  proposeRewardSchedule: ({
    description,
    endBlockTime,
    lpToken,
    startBlockTime,
    title
  }: {
    description?: string;
    endBlockTime: number;
    lpToken: Addr;
    startBlockTime: number;
    title: string;
  }, $fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
  reviewRewardScheduleProposals: ({
    reviews
  }: {
    reviews: ReviewProposedRewardSchedule[];
  }, $fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
  dropRewardScheduleProposal: ({
    proposalId
  }: {
    proposalId: number;
  }, $fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
  allowLpToken: ({
    lpToken
  }: {
    lpToken: Addr;
  }, $fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
  removeLpToken: ({
    lpToken
  }: {
    lpToken: Addr;
  }, $fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
  receive: ({
    amount,
    msg,
    sender
  }: {
    amount: Uint128;
    msg: Binary;
    sender: string;
  }, $fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
  bond: ({
    amount,
    lpToken
  }: {
    amount: Uint128;
    lpToken: Addr;
  }, $fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
  unbond: ({
    amount,
    lpToken
  }: {
    amount?: Uint128;
    lpToken: Addr;
  }, $fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
  instantUnbond: ({
    amount,
    lpToken
  }: {
    amount: Uint128;
    lpToken: Addr;
  }, $fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
  unlock: ({
    lpToken
  }: {
    lpToken: Addr;
  }, $fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
  instantUnlock: ({
    lpToken,
    tokenLocks
  }: {
    lpToken: Addr;
    tokenLocks: TokenLock[];
  }, $fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
  withdraw: ({
    lpToken
  }: {
    lpToken: Addr;
  }, $fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
  claimUnallocatedReward: ({
    rewardScheduleId
  }: {
    rewardScheduleId: number;
  }, $fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
  proposeNewOwner: ({
    expiresIn,
    owner
  }: {
    expiresIn: number;
    owner: Addr;
  }, $fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
  claimOwnership: ($fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
  dropOwnershipProposal: ($fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
}
export class MultiStakingClient extends MultiStakingQueryClient implements MultiStakingInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.updateConfig = this.updateConfig.bind(this);
    this.proposeRewardSchedule = this.proposeRewardSchedule.bind(this);
    this.reviewRewardScheduleProposals = this.reviewRewardScheduleProposals.bind(this);
    this.dropRewardScheduleProposal = this.dropRewardScheduleProposal.bind(this);
    this.allowLpToken = this.allowLpToken.bind(this);
    this.removeLpToken = this.removeLpToken.bind(this);
    this.receive = this.receive.bind(this);
    this.bond = this.bond.bind(this);
    this.unbond = this.unbond.bind(this);
    this.instantUnbond = this.instantUnbond.bind(this);
    this.unlock = this.unlock.bind(this);
    this.instantUnlock = this.instantUnlock.bind(this);
    this.withdraw = this.withdraw.bind(this);
    this.claimUnallocatedReward = this.claimUnallocatedReward.bind(this);
    this.proposeNewOwner = this.proposeNewOwner.bind(this);
    this.claimOwnership = this.claimOwnership.bind(this);
    this.dropOwnershipProposal = this.dropOwnershipProposal.bind(this);
  }

  updateConfig = async ({
    feeTierInterval,
    instantUnbondFeeBp,
    instantUnbondMinFeeBp,
    keeperAddr,
    minimumRewardScheduleProposalStartDelay,
    unlockPeriod
  }: {
    feeTierInterval?: number;
    instantUnbondFeeBp?: number;
    instantUnbondMinFeeBp?: number;
    keeperAddr?: Addr;
    minimumRewardScheduleProposalStartDelay?: number;
    unlockPeriod?: number;
  }, $fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_config: {
        fee_tier_interval: feeTierInterval,
        instant_unbond_fee_bp: instantUnbondFeeBp,
        instant_unbond_min_fee_bp: instantUnbondMinFeeBp,
        keeper_addr: keeperAddr,
        minimum_reward_schedule_proposal_start_delay: minimumRewardScheduleProposalStartDelay,
        unlock_period: unlockPeriod
      }
    }, $fee, $memo, $funds);
  };
  proposeRewardSchedule = async ({
    description,
    endBlockTime,
    lpToken,
    startBlockTime,
    title
  }: {
    description?: string;
    endBlockTime: number;
    lpToken: Addr;
    startBlockTime: number;
    title: string;
  }, $fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      propose_reward_schedule: {
        description,
        end_block_time: endBlockTime,
        lp_token: lpToken,
        start_block_time: startBlockTime,
        title
      }
    }, $fee, $memo, $funds);
  };
  reviewRewardScheduleProposals = async ({
    reviews
  }: {
    reviews: ReviewProposedRewardSchedule[];
  }, $fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      review_reward_schedule_proposals: {
        reviews
      }
    }, $fee, $memo, $funds);
  };
  dropRewardScheduleProposal = async ({
    proposalId
  }: {
    proposalId: number;
  }, $fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      drop_reward_schedule_proposal: {
        proposal_id: proposalId
      }
    }, $fee, $memo, $funds);
  };
  allowLpToken = async ({
    lpToken
  }: {
    lpToken: Addr;
  }, $fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      allow_lp_token: {
        lp_token: lpToken
      }
    }, $fee, $memo, $funds);
  };
  removeLpToken = async ({
    lpToken
  }: {
    lpToken: Addr;
  }, $fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      remove_lp_token: {
        lp_token: lpToken
      }
    }, $fee, $memo, $funds);
  };
  receive = async ({
    amount,
    msg,
    sender
  }: {
    amount: Uint128;
    msg: Binary;
    sender: string;
  }, $fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      receive: {
        amount,
        msg,
        sender
      }
    }, $fee, $memo, $funds);
  };
  bond = async ({
    amount,
    lpToken
  }: {
    amount: Uint128;
    lpToken: Addr;
  }, $fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      bond: {
        amount,
        lp_token: lpToken
      }
    }, $fee, $memo, $funds);
  };
  unbond = async ({
    amount,
    lpToken
  }: {
    amount?: Uint128;
    lpToken: Addr;
  }, $fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      unbond: {
        amount,
        lp_token: lpToken
      }
    }, $fee, $memo, $funds);
  };
  instantUnbond = async ({
    amount,
    lpToken
  }: {
    amount: Uint128;
    lpToken: Addr;
  }, $fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      instant_unbond: {
        amount,
        lp_token: lpToken
      }
    }, $fee, $memo, $funds);
  };
  unlock = async ({
    lpToken
  }: {
    lpToken: Addr;
  }, $fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      unlock: {
        lp_token: lpToken
      }
    }, $fee, $memo, $funds);
  };
  instantUnlock = async ({
    lpToken,
    tokenLocks
  }: {
    lpToken: Addr;
    tokenLocks: TokenLock[];
  }, $fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      instant_unlock: {
        lp_token: lpToken,
        token_locks: tokenLocks
      }
    }, $fee, $memo, $funds);
  };
  withdraw = async ({
    lpToken
  }: {
    lpToken: Addr;
  }, $fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      withdraw: {
        lp_token: lpToken
      }
    }, $fee, $memo, $funds);
  };
  claimUnallocatedReward = async ({
    rewardScheduleId
  }: {
    rewardScheduleId: number;
  }, $fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      claim_unallocated_reward: {
        reward_schedule_id: rewardScheduleId
      }
    }, $fee, $memo, $funds);
  };
  proposeNewOwner = async ({
    expiresIn,
    owner
  }: {
    expiresIn: number;
    owner: Addr;
  }, $fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      propose_new_owner: {
        expires_in: expiresIn,
        owner
      }
    }, $fee, $memo, $funds);
  };
  claimOwnership = async ($fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      claim_ownership: {}
    }, $fee, $memo, $funds);
  };
  dropOwnershipProposal = async ($fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      drop_ownership_proposal: {}
    }, $fee, $memo, $funds);
  };
}